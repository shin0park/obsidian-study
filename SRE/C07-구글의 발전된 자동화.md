
### 자동화의 가치
#### 일관성
- 아무리 노력하더라도 사람이 기계처럼 일관성을 가지기란 불가능에 가깝다.
- 실수와 간과로 인해 결국 신뢰성의 문제로 발전하게 된다.
- 자동화가 최우선적으로 추구하는 가치 (정확하게 정의된 업무 범위와 정해진 절차를 수행)

#### 플랫폼
- 자동화 시스템은 확장이 가능하고 다른 시스템에도 적용이 가능하며, 이윤을 창출할 수 있는 *플랫폼*을 제공
- 이런 플랫폼은 실수를 *중앙집중화* 하는 데도 도움된다. (사람이 수동으로 수정해야될 것을 자동화 코드 한번 수정으로 해결 가능)

#### 신속한 수리
- 평균 고장 후 수리시간 (Mean Time To Repair, MTTR) 절감 가능
- 문제의 재발 방지
- 수리 후 정리 절차 수행하는 등 남는 시간을 다른 곳에 활용 가능 => 업무 수행 속도 향상

#### 신속한 조치
- 사람이 기계만큼 빠르게 대응하는 것이 대체로 불가능하다.
- 구글은 오래 전부터 수동으로 진행되는 운영 업무의 한계를 알고있기에 엄청난 규모의 자동화 시스템을 구축하고 있다.

#### 시간 절감
- 자동화 필요성에 대한 *근거*
- 자동화의 당위성
- 사실은 이 이점을 바로 계산하기는 힘들지만 적절하게 자동화를 활용하면 시간 절감을 누릴 수 있다.

### 구글 SRE 가치
- 구글은 자동화에 대한 강한 성향을 가지고 있다.
- 벤더로부터 사용가능한 API가 제공 되지 않는다면 직접 이를 개발한다.
- 단기적으로 특정 작업을 위해 소프트웨어를 구매하는 것이 더 저렴해도, 직접 솔루션을 작성한다. 
- => 큰 이것이 장기적인 이점을 가져오기 때문에
- 자동화 시스템을 개발하는데 많은 시간을 투자한다.

### 자동화 사례
- 사용자 계정 생성
- 서비스를 위한 클러스터 턴업(turnup)이나 턴다운(turndown)
- 소프트웨어 혹은 하드웨어 설치 준비 및 해제
- 새로운 버전의 소프트웨어 출시(rollout)
- 런타임 설정 변경

### 자동화 클래스의 계층 구조
- 자동화 구축시, 외부 시스템과 통합하기 위한 로직은 배제하는 편이 낫다 - 내재화가 더 효율적일 뿐만 아니라, 자동화 자체가 외부 시스템과의 통합 로직이 필요하지 않도록 광된 것.
- 불일치: 자동화가 핵심 시스템과 별개로 유지보수 되면, 기반시스템이 변경되었음에도 불구하고 자동화 시스템은 이에 따라 변경되지 않음으로써 문제가 발생하기 십상이다.-> 변경의 거부감으로 어쩌다가 한번 배포하게되며 문제가 더 빈번하게 발생할 수도 있다
#### 자동화의 혁신 단계
1. 자동화를 하지 않는 단계
   - 수동으로 진행
2. 별도로 관리되며 시스템에 특화된 자동화를 수행하는 단계
   - SRE가 홈 디렉토리에서 장애대응 스크립트 수행
3. 별도로 관리되는 범용 자동화를 수행하는 단계
   - SRE가 모두가 사용하는 "범용 장애 대응"스크립트에 추가하여 수행
4. 내재화되었지만 시스템에 특화된 자동화를 수행하는 단계
   - 자체적으로 내장된 장애 대응 스크립트 실행
5. 자동화가 불필요한 시스템을 도입하는 단계
   - 문제를 직접 보고하고 사람개입없이 자동으로 장애대응 수행

- 수동 작업을 피할수 없는 경우도 분명히 존재 -> 반드시 안전하게 관리되어야 하며 필요시 롤백이 가능해야한다.

### 스스로를 이롭게 하라: 몽땅 자동화하자.
*구글의 클러스터 스케줄링 시스템인 보그에 MYSQL을 마이그레이션 해야하는 상황 발생*

이를 통해 다음 두가지 목표 달성 가능
- 보그를 통해 자동으로 새로운 작업을 설정하거나 문제가 발생한 작업을 재시작하게됨으로써 주장비와 복제장비에 대한 관리 부하 완전히 제거
- 보그 컨테이너 관리 기능을 통해 머신의 리소스를 더욱 효율적으로 활용함으로써 동일한 물리적 머신에 여러 MYSQL 인스턴스를 바이너리 단위로 패키징 가능

보그에 시험용 MYSQL 인스턴스를 성공적으로 배포했지만,
다음의 문제 발생
- 설정된 작업이 자동으로 옮겨다닌다는 점 -> 마스터 인스턴스에서는 있으면 안됨
- 수동 장애대응 시간 상당한 시간 소요
- 에러 예산 충족하려면 각 장애 대응시 발생하는 다운타임 30초 이내여야 하지만 사람의 절차가 이 이내에 완료될 수가 없다.

해결책
-> 장애 대응 자동화
-> *디사이더(Decider)* 장애 대응 데몬 개발
-> 이로써 가장 높은 가용성을 제공하는 MySQL 인프라 구축하게됨
-> 운영 작업에 소요하던 시간 95%까지 절감
-> infrastructure 개선하기 위한 시간이 증가함.
-> 마이그레이션 성공으로 하나의 머신에 여러개 MySQL 인스턴스 띄울 수 있게 되어 -> 자원도 절약


### 신의 한수: 클러스터 턴업의 자동화

클러스터 턴업 할때마다 SRE팀은 채용을 해야될 정도였으며,
어떤 시스템은 백개 이상의 컴포넌트 서브시스템으로 구성되었고 의존성이 복잡하여 장애를 겪게되기 일쑤 였다.

#### Prodtest를 이용한 모순의 발견
클러스터 수가 늘어남에따라 관리해야할 클러스터 증가
-> 시간 낭비를 유발하는 설정오류들 증가

*Prodtest* 이 해결책으로 등장
-> 파이썬의 단위테스트 프레임워크를 확장하여 실제 운영중인 서비스에 대한 단위테스트가 가능하도록 개조한것.
의존성을 고려하여 여러개 테스트 연결하여 수행가능하며 어느 하나라도 실패하면 테스트 중단
`+` 단위 테스트 상태를 그래프로 생성 -> 신속하게 오류 확인 가능

#### 멱등성을 이용한 모순의 해결
SRE는 갑자기 의사 결정자로들 부터 일주일 내에 설정을 마쳐야 한다는 끔찍한 임무를 받는다.

- Prodtest를 통해 잘못된 설정을 빠르게 찾을 수 있었으므로 잘못된 설정을 수정하는 파이썬 코드를 연결했다. 
  즉, 각각의 테스트와 해당 테스트가 실패하는 원인을 수정하는 코드를 모두 짝지어 놓는 것이다.
- Bug fix가 멱등성을 염두해 두고 작성되었다면 필요한 모든 의존성에 부합할 것이고, 쉽고 안전하게 문제 해결 기대할 수 있다.

모순존재
- 테스트와 수정사이의 지연(latency)문제
- 두번째 테스트는 제대로 동작하다 말다하는 불안정한 테스트
- 버그픽스들이 본질적인 멱등성을 확보할 수 없음
=> 오히려 모순된 상태에 놓이게 됨

자동화는 세가지 관점에 따라 다르게 진행된다. 
- 적합성
- 지연시간, 실행후 얼마나 빠르게 모든 단계가 실행되는가
- 자동화와 실제 프로세스 사이의 연관성 또는 자동화에 의해 처리되는 비율

지연시간 감소를 위해
- 턴업팀 대상으로 교육 진행 - 어떤 자동화 스크립트를 실행해야하는가
- 턴업시 티켓 사용으로 추적 가능
#### 서비스 지향 클러스터 턴업
- 턴업프로세스는 해당 서비스의 소유권을 가진 팀이 담당하는 것이 더 낫다는 것을 시작으로
- 서비스 지향 아키텍처

### 보그: 창고 크기 컴퓨터의 탄생

구글 클러스터 초기
- 머신들로 가득찬 서버랙에 잡다한 설정 적용한 형태로 배포 - 마스터 머신에 로그인하여 관리작업 

그러다가 자동화 개발이 본격화

초기자동화: 간단한 파이썬 스크립트 구성
- 서비스 관리
- 어떤 머신에서 어떤 서비스가 실행중인지 추적
- 로그메시지 파싱
-> 결국 자동화는 머신 상태를 추적하는 적절한 데이터 베이스 형태로 변화함

하지만 시스템의 추상화가 물리적인 머신과 너무나도 강력하게 결합되어 있어 한계가 존대

보그
-> 상대적으로 정적이었던 호스트/포트/작업 할당 방식에서 벗어나 일련의 머신들을 관리하는 리소스로 취급
-> 이전 머신에 대한 '소유권'과는 달리 머신에 대한 *스케줄링*을 허용
-> 이로써 적은양의 일정한 노력으로 지속적이며 자동화된 운영체제 업그레이드 가능


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

핵심내용
- 자동화의 가치 (일관성, 플랫폼, 신속한 수리와 조치, 시간 절감)
- 자동화의 혁신 단계
- 자동화 사례들 ( 보그 Mysql 마이그레이션, 클러스터 턴업의 자동화)

알게된점
- 결국 자동화가 불필요한 시스템을 도입하는 것이 자동화 혁신단계의 마지막 단계
- 구글의 여러 자동화의 사례들과 역사