
구글 모니터링 시스템
새로운 패러다임으로 약 10년에 걸쳐 진화해왔다.
새로운 모델에서는 시계열(time-series)데이터를 수집하고, 이를 토대로 차트와 알림을 생성할 수 있는 커스텀 스크립트를 다양한 언어로 만들어왔다.
=> 보그몬
### 보그몬 Borgmon
- 공용 데이터 해설 형식(common data exposition format)을 사용하여 낮은 오버헤드로 대량의 데이터를 수집하며, 데이터 처리 프로세스의 실행과 네트워크 연결 설정에 다른 비용을 없애준다.
- 데이터는 차트의 랜더링과 알림생성에 사용되며, 수학적 연산을 통해 이뤄진다.
- 화이트박스 모니터링
- 대량의 데이터를 수집하기 위한 지표의 형식은 표준화 되어있다.
- 보그몬은 다른 보그몬으로부터 데이터 수집 가능하다.
- 보그몬을 계층구조로 구성하거나 여러개 보그몬 인스턴스가 존재하는 샤드를 구성하여 클러스터 형태로 구성하기도 한다.

#### 보그몬 데이터 수집
- 보그몬은 자신의 대상(데이터 수집할 대상을 의미?)을 찾기 위한 다양한 기법이 적용된 대상 리스트를 갖고 있다.
- 대상 리스트는 동적이여서 service discovery를 이용하변 모니터링 시스템을 손쉽게 스케일링하고 운영 비용을 줄일 수 있다.
- 보그몬은 지정된 간격으로 각 대상마다 URL를 호출하고 그 결과를 디코드하여 메모리에 저장한다.
- 보그몬이 각 대상을 인식하기 위해 아래의 변수를 기록한다.
	- 대상의 이름이 host와 port 번호로 해석되었는지 여부
	- 대상이 데이터 수집에 응답했는지 여부
	- 대상이 healthcheck 요청에 응답했는지 여부
	- 데이터 수집이 완료된 시각
- 이러한 변수를 사용하면 모니터링 중인 task가 불가능한 상태가 되었을때 감지하기위한 rule을 쉽게 작성 할 수 있다.

#### 시계열 데이터를 위한 저장소
- 보그몬은 모든데이터를 인-메모리(in-memory) 데이터베이스에 저장한다. 그리고 정기적으로 디스크에 다시 저장된다.
- 데이터가 저장되는 시점은 일련의 형태(시간,값)를 가지며, 시계열(time-series)라 불리는 연대별 list 형태로 저장된다.
- 하나의 host에 대한 시간에 대한 수들의 일차원 행렬을, 이 시계열에 다른 host의 순열을 추가하면 다차원 행렬이된다.
  -> 이 구조는 고정된 크기의 메모리 블록이다.
  -> *time-series area* 시계열 공간이라 부른다.
- 공간이 가득 차면 가비지 컬렉터가 가장 오래된 항목부터 차례로 제거해나간다.
	- 또한 정기적으로 Time-series Database 시계열 데이터베이스라고 알려진 외부 시스템에 보관하며, 보그몬은 오래된 데이터는 TSDB에 쿼리한다. RAM보다는 느리지만 저렴한 비용으로 더 많은 데이터를 보관할 수 있다.
#### 레이블과 벡터
- 시계열 데이터는 일련의 숫자와 타임스탬프 값으로 저장되는데, 이 값을 vector 벡터라고 한다.
- 시계열 데이터의 이름을 labelset 레이블셋이라고 한다. key=value 쌍으로 표현되는 레이블의 집합으로 구현되기 때문에
- 시계열 데이터는 식별이 가능해야하므로 최소한 다음의 레이블을 가지고 있어야한다.
	- var: 변수이름, job: 모니터링되는 서버의 타입이름, service: 사용자에게 서비스를 제공하는 내부 외부 잡의 집합, zone: 데이터센터
- 변수 표현식
	- `{var=http_requests,job=webserver,instance=host0:80,service=web,zone=us-west}`
- 시계열데이터를 쿼리하기 위해 이 모든 레이블을 명시할 필요는 없다.

#### 보그몬 규칙 Borgmon rule
- 보그몬은 실제로 단지 알림을 생성하기 위한 몇가지 문법적 편의성을 제공하는 프로그래밍이 가능한 계산기이다.
- 데이터 수집과 저장을 위한 컴포넌트는 이를 위한 것들이다.
- 보그몬 규칙: 시계열 데이터를 계산하는 간단한 수학 표현식으로 이뤄진다. 하나의 시계열 데이터의 기록을 쿼리하거나, 여러개 데이터로 부터 각기 다른 레이블셋을 한번에 쿼리하거나 다양한 수학적 연산을 적용가능하므로 매우 강력해질 수 있다.
- 다양한 연산 예시
	- `rate({var=http_requests,job=webserver}[10m])`-> 레이블별 비율 계산, 
	  10분의 시간 범위를 지정한 이유: 데이터 수집오류로 인해 데이터가 유실되는 것을 피하기 위해
	- `sum without instance()`-> 괄호 안의 데이터중 인스턴스 레이블을 제외
	- `code=!/200/`-> code가 200인 데이터만 제외, 레이블 자체가 제외되진 않음

#### 알림
- 보그몬은 알람 규칙을 평가해서 결과가 참이면 발송, 거짓이면 발송하지 않는다.
- 알람보내기 전 일정 시간동안 반드시 참이어야하는 조건을 추가할 수 있다.
- 통상 규칙을 최소 두번이상 실행하여 잘못된 알림을 가지 않게 한다.
- 알림 규칙은 메시지에 문맥에 따른 정보를 추가할 수 있는 *템플릿* 가지고 있다. (잡이름, 알림의 이름, 발송 규칙을 의미하는 숫자값들)
- 보그몬은 중앙집중식인 알림매니저라는 서비스에 연결하여 알림을 전송한다.
- 알림매니저는 다음과 같이 구성한다.
	- 다른 알림이 활성화된 상태일때 특정 알림을 억제한다.
	- 동일한 레이블셋을 가진 여러개의 보그몬으로부터 중복된 알림을 제거한다.
	- 유사한 레이블셍으로부터 여러개의 알림이 전송된 경우, 레이블 셋에 따라 알림을 축소하거나 확대한다.

#### 계층화된 보그몬 모델
- 보그몬은 다른 보그몬으로부터 데이터를 가져올 수 있고 한 보그몬이 전체 서비스의 모든 태스크로부터 데이터를 수집할 수 있으므로 그 보그몬은 금세 병목 지점이 될 수 있다.
- 따라서 통상적으로, 최상위에 두개 혹은 그 이상의 전역 보그몬을 설치하고, 각 데이터 센터마다 해당 지역에서 실행되는 모든 잡들을 감시하기 위한 각각의 보그몬을 설치한다. 그 하위에는 더 상세한 수집전용 계층인 DC 집계계층 (데이터 집계를 위한 대부분 규칙 평가를 수행)
- 전역 보그몬 -> 데이터센터 보그몬 -> DC집계보그몬 -> 애플리케이션태스크 

#### Prober 프로버
- 보그몬은 화이트박스 모니터링 시스템: 대상 서비스의 내부 상태를 언제든 확인 가능하다.
- 하지만 화이트박스 모니터링이기때문에 사용자가 실제로 보는 것을 알아채지 못할 수 있다. (DNS  오류, 서버장애로 유실된 쿼리 등)
- 구글팀은 프로버 Prober (대상에 대해 프로토콜 검사를 실행하고 그 결과를 보고 하는 시스템)을 통해 이 부분을 해결한다.
- 프로버는 자신이 varz API를 구성해서 보그몬이 이를 수집할 수 있게 한다.
- 프로버는 프로토콜의 응답 페이로드(HTTP 응답의 HTML콘텐츠)의 유효성 검사는 물론, 그 값을 시계열 데이터로 추출하여 내보낼 수 있다.

#### 설정의 유지보수
- 보그몬의 설정은 동일한 규칙의 집합을 여러 대상에 동시에 적용할 수 있도록 구성되어있다.
- 반복적인 부분을 해소할 수 있으므로 모니터링 운영비용이 상당히 감소한다.
- 보그몬은 언어 템플릿 을 지원한다. -> 규칙의 라이브러리를 구성하고 재사용이가능하다.
- 지속적 통합 서비스를 통해 설정을 패키지화해서 사용가능하다.
- 이러한 공용템플릿이 만들어졌지만 두가지 모니터링 설정 클래스가 두드러진다.
	1. 단순히 해당 라이브러리의 변수의 스키마를 코드화 하여 어떤 사용자도 자신만의 varz API를 위한 템플릿으로 재사용가능하다.
	2. 단일 서버의 태스크부터 전역까지 집계한 데이터를 관리하기 위한 템플릿
	   레이블링 규칙을 통해 특정 하위 컴포넌트를 시스템의 나머지 컴포넌트들로부터 완전히 격리가능 -> 레이블을 통해 시계열 데이터를 그룹화하고 집계

https://sre.google/sre-book/practical-alerting/