## 릴리즈 엔지니어링

#### 릴리즈 엔지니어
- 소프트웨어를 build and delivery 하는 과정을 간략하게 기술하는 분야이다.
- 릴리즈 엔지니어는 소스코드관리, 컴파일러, 빌드 설정 언어, 빌드 자동화 도구, 패키지 관리자 및 설치도구에 대해 잘 이해하고 있다.
- 신뢰성있는 서비스를 운영하기 위해서는 릴리즈 프로세스가 필요하며, 해당 프로세스는 각기 다른 것이 아닌 언제든 동일하게 반복 실행될 수 있어야 한다.
- 릴리즈 프로세스에 대한 모든 변경은 반드시 그 의도를 가지고 이루어져야 한다.
- 구글에서는 릴리즈 엔지니어링은 별도의 특정 직업군으로 sre와 함께 일하며 릴리즈에 필요한 모든 단계를 정의한다.

#### 릴리즈 엔지니어의 역할
- 일관되고 반복 가능한 방법을 통해 프로젝트를 릴리즈하기 위한 최선의 방법을 정의한다.
- 예를들어, 컴파일러의 플래그, 빌드 식별 태그 형식, 빌드과정에서 필요한 단계들 등이 있다.
- 비즈니스 요구사항을 충족할 수 있는 릴리즈 프로세스를 유지하기 위해 SRE와 함께 단계별 변경 적용 전략, 무중단 릴리즈 배포 방법, 롤백 등을 함께 개발한다.

#### 릴리즈 엔지니어링의 철학
1. 자기 주도 서비스 모델
   - 팀은 반드신 *자기 주도적*이어야 한댜.
   - 릴리즈 엔지니어링은 모든 릴리즈 프로세스를 담당하므로, 수천 명의 엔지니어와 제품을 보유하고 있을 것이다. 
     그럼에도 개별 팀이 얼마나 자주, 새로운 버전의 제품을 릴리즈 할 수 있는지 결정하도록 하면, 빠른 속도로 릴리즈가 가능하다.
   - 릴리즈 프로세스는 *자동화*를 통해 엔지니어 개입을 최소화 한다. 자동 빌드시스템과 배포 도구로 자동으로 빌드되고 배포되도록 한다.
   
2. 빠른 릴리즈 주기
   - 변경사항을 자주, 빠르게 릴리즈해야한다.
   - 한시간 단위로 빌드를 수행한 후, 완료된 것들 중 실제 프로덕션 환경에 배포될 버전을 선택하거나, 'Push on Green'으로 매 빌드가 모든 테스트를 통과하면 배포를 하기도 한다.

3. 밀폐된 빌드
   - 빌드 도구는 일관성과 반복성을 제공해야한다.
   - 즉, 빌드는 완전히 밀폐된 구조여야한다. 
   - 다른 라이브러리나 소프트웨어에 영향받지 않고 언제나 동일한 코드와 버전이라면 같은 결과가 나와야한다.
   - 빌드 환경 외부의 서비스에 의존하면 안된다.
   - 이미 실행중인 소프트웨어의 버그를 수정하기 위해 기존 릴리즈를 다시 빌드하는 것은 어려운 일이다 
     원래의 것과 같은 revision을 다시 빌드한 후 여기에 새 변경사항을 추가하는 방식으로 해결 했다 
     -> 이를 *전략적 선별(tatic cherry picking) 이라고 한다.*
 
4. 원리와 절차의 강제
   - 릴리즈 할때 여러 단계의 보안 및 접근 제어 계층이 존재한다.
	   - 소스 코드 변경 수락
	   - 릴리즈 과정에서 수행해야할 행위의 정의
	   - 새 릴리즈 생성
	   - 기본 통합 제안의 수락 및 이후 코드 변경 선별
	   - 새 릴리즈 배포
	   - 프로젝트 빌드 설정의 변경
   - 모든 변경은 코드리뷰를 받아야한다.

#### 지속적 빌드와 배포
구글은 "래피드(Rapid)"라는 *자동화된 릴리즈 시스템*을 개발 했다.
- 확장 가능하고 독립적이며 신뢰할 수 있는 릴리즈를 빌드하기 위한 프레임워크를 제공하고, 구글의 다양한 기술들을 활용하는 시스템

빌드
- 블레이즈(Blaze): 구글의 빌드 도구
- 다양한 언어들의 바이너리를 빌드
- 엔지니어는 블레이즈를 통해 빌드 대상과 의존성을 정의하고, 블레이즈는 빌드가 실행될때 자동으로 의존 대상들을 빌드한다.
- 바이너리의 빌드 대상과 단위 테스트는 래피드의 프로젝트 설정 파일에 정의된다. 

Branch
- 주 브랜치에서 직접 릴리즈를 수행하지 않는다.
- 주 브랜치로부터 특정 리비전에 대한 브랜치를 생성하며, 절대 이 브랜치는 주 브랜치로 머지하지 않는다.
- 릴리즈에 포함하고자 하는 변경사항을 cherry-pick 하여, 관련 없는 변경사항이 적용되는 것을 방지한다.

태스트
- 변경된 코드가 제출될때마다 자동으로 단위테스트를 실행한다.
- 프로젝트 릴리즈와 동일한 대상을 지속적 빌드의 테스트 대상으로 설정하는 것을 권장한다.
- 마지막으로 지속적 테스트 빌드를 성공한 리비전 번호를 릴리즈로 생성하는 것을 권장한다.
- 모든 테스트를 통해 감사기록을 남길 수 있다.

패키징
- Midas Package Manager,MPM은 패키지를 관리한다.
- 패키지는 각가의 이름이 있으며, 해시를 통해 버전이 저장되고, 인증을 위한 서명이 되어있다.
- 패키지의 특정 버전에 레이블을 지정하는 것을 지원한다. (래피드는 빌드ID를 레이블로 지정한다. 이를 통해, 패키지 이름 및 레이블로 특정 패키지를 참조)

(래피드 예시)
- 래피드는 blueprint파일에 정의된 배포 정의를 바탕으로 새로 필드된 MPM패키지를 사용하고 테스트 실행자를 지정한다.

배포
- 시시포스(Sisyphus): 구글 sre가 개발한 롤아웃 자동화 프레임워크
- (롤아웃이란 하나 혹은 그 이상의 개별 테스트로 이루어진 논리적인 작업의 단위)
- 시시포스 - 어떤 배포 프로세스도 지원 가능하도록 확장한 파이썬 클래스의 집합제공, 대시보드를 통해 롤아웃 실행되는 과정을 모니터링 가능
- 래피드가 생성한 MPM 패키지의 빌드 레이블을 인식하여 시시포스에 롤아웃을 생성할때, 해당 빌드 레이블을 지정할 수 있다. 이를 통해 시시포스는 어떤 버전의 MPM패키지가 배포 할지 지정할 수 있다.

#### 설정 관리 기법
- 설정 관리는 릴리즈 엔지니어와 sre가 가깝게 협업하는 분야 중 하나이다.
- 모든 설정은 철저한 코드리뷰를 해야하 한다.
- 4가지 방법 존재
	- 주 브랜치에서 설정파일을 수정.
		- 코드리뷰를 거쳐 실행 중인 시스템에 적용 - 바이너리 릴리즈와 설정 변경을 분리
		- 절차는 간단했지만, 체크인된 버전의 설정파일과 실제 동작하는 버전의 설정파일 간의 불일치가 빈번히 발생
	- 설정파일과 바이너리를 동일한 MPM 패키지로 묶는 방법
		- 설정파일이 적은 경우 혹은 자주 파일을 변경하는 경우, 바이너리와 설정파일을 동일한 MPM 패키지에 추가
		- 강한 결합으로 유연성 감소하지만, 패키지 하나만 설치하면 되므로 간편하다
	- MPM 설정 패키지에 설정파일을 추가
		- 만약 두가지의 새로운 설정 함께 릴리즈하고자 한다면, 두개의 MPM 패키지를 생성하므로, 각 패키지의 변경을 독립적으로 유지 할 수 있다.
		- 다른 하나의 설정으로 변경하고자 할때, 설정 패키지만 다시 빌드한 후 배포하면 그만이다.
		- 새로운 바이너리 빌드를 배포할 필요가 없다는 장점이 있다.
	- 설정을 외부 저장소에서 읽는 방법
		- 설정 파일이 빈번하게 or 동적으로 변경되는 경우 사용

	-> 가장 적합한지는 상황에 알맞게 선택하자

참고,
- 릴리즈 엔지니어링은 구글 뿐만 아닌 모두에게 적용되어야한다.
- 릴리즈 엔지니어링은 처음부터 도입해야한다.
- 개발자, sre, 릴리즈 엔지니어가 함께 일하는 것은 너무 당연하며, 릴리즈 엔지니어는 코드의 빌드와 배포에 대한 의도를 반드시 이해해야한다.
- 빌드는 개발자가 의해서가 아닌 릴리즈 엔지니어에 의해 이루어져야한다.

## 간결함

시스템의 안정성 vs 신속함
- 간혹 신속함을 위해 안정성을 희생할 수 있다. - 실험적코딩 (일단은 실패할 것을 어느정도 예상하고 코드를 작성해보는 것)
- 안정성과 신속함의 적절한 균형을 이뤄야한다.
- 신뢰성을 주면된다? - 신뢰성을 위한 프로세스는 개발자들의 신속성을 높히는 경향이 있다.
- 신뢰성을 주입하면 개발자들은 소프트웨어와 시스템 기능과 성능에만 집중 가능하다.

지루함의 미덕 
- "지루함" - 소프트웨어 분야에서는 긍정적인 요소이다.
- 근본적인 복잡성, 돌발적인 복잡성이 존재하는데, 돌발적인 복잡성은 엔지니어의 노력으로 해결가능하다. - sre는 이런 돌발적인 복잡성을 야기하는 요소를 제거해야한다.

내 코드는 절대 포기하지 않아?
- 나중에 쓸것 같은데 하고 남겨 놓는, 혹시 몰라 주석처리 해놓는 코드 -  코드를 산만하게 만들고 혼란만 가중시킨다.
- 새로 작성되는 코드 한줄 한줄이 모두 부채라고 생각해야한다.
- 따라서 SRE는 실제로 목표를 달성하고 있는 코드인지 확인하거나 사용되지 않는 코드를 주기적으로 삭제하는 또는 테스트 과정에서 자원을 과도하게 소모하는 부분을 탐지하는 기능을 구현한다.
- 소프트웨어 팽창 - 소프트웨어가 시간이 지나면서 계속 추가되고 점차 느려지고 비대해지는 현상
  -> 더이상 유용하지 않는 수천 줄의 코드를 한번에 삭제했던 것이 저자의 경험중 가장 적잘했던 코딩이였다.

최소한의 api
- api를 최소화하는 것은 소프트웨어 시스템의 "간결함"을 추구하기 위한 가장 기본적인 관점이다.
- 이로써 핵심 문제에 집중하고 훨씬 나은 해결책을 모색할 수 있다.
- api를 버전별로 관리하여, 개발자가 새로운 버전을 안전하고 적절한 방법으로 추가 할 수 있다 

릴리즈의 간소화
- 일반적으로 간결한 릴리즈가 복잡한 릴리즈보다 낫다
- 릴리즈를 더 작은 단위로 정의한다면 더 강한 확신을 갖고 움직일 수 있다.
- 해결책을 찾기가 더 쉽다.

결론
 - 결국 소프트웨어의 간결함은 신뢰성을 위한 사전 조건이다.
 - 항상 주어진 작업에서 각 단계를 간소화 하고자 노력해야한다.
 - 우리의 환경이 난잡해지지 않도록 유지하고 혁신에 정면에 집중하자.
