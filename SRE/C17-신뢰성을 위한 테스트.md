## 신뢰성을 위한 테스트 (Testing for Reliability)

### 신뢰성의 중요성과 테스트의 역할

- SRE의 주요 책임은 시스템 신뢰성을 **정량적으로 평가**하는 것.
- 신뢰성은 과거 데이터를 기반으로 한 **과거 신뢰성**(데이터 분석)과, 이를 바탕으로 미래를 예측하는 **미래 신뢰성**(과거 데이터로부터 예측)으로 나뉜다.
- 테스트는 변경 사항이 발생할 때 특정 부분에서 동일한 결과를 기대할 수 있다는 것을 보여주는 신뢰성을 보장하는 핵심 메커니즘이다.
    - 테스트를 통해 변경 전후 시스템이 완전 동일한 상태여야 한다.
    - 변경이 잦아질수록 예측 신뢰성이 감소하며, 충분한 데이터와 테스트가 보완하여 신뢰성을 검증해야 한다.
- 테스트와 수정에 소요된 시간과의 관계
	- **Zero MTTR 테스트**: 테스트가 문제를 사전에 발견하여 배포를 차단함으로써 평균 복구 시간을 0으로 만듦
	- 이는 사용자 경험을 보호하며, 시스템의 장애 발생 시간의 간격(MTBF, Mean Time Between Failure)을 증가시킨다.
	- 테스트를 보완함으로써 MTBF가 증가하면, 개발자들은 새로운 기능을 더 빨리 릴리즈 할 수 있다.

## 소프트웨어 테스트의 종류

1. 전통적인 테스트 : 소프트웨어를 개발하는 동안 테스트
	1. 단위 테스트(unit test): 소프트웨어의 개별 기능을 독립적으로 검증
	   - 주로 TDD(Test-Driven Development) 방법론과 함께 사용.
	2. 통합 테스트 (integration test): 개별 구성 요소를 결합하여 전체 동작을 확인
	   - 의존된 객체들의 mock 객체(Dagger, DI dependency injection)를 생성(의존성 주입)하여 테스트
	3. 시스템 테스트: 시스템 전체를 검증, 아직 배포되지 않은 시스템에 대해 수행 할 수 있는 가장 **큰규모**의 테스트
		1. 스모크 테스트 (smoke test) : 가장 간단한 형태의 테스트로, 중요한 동작을 테스트
		    - 안정성 검사(sanity test)
		2. 성능 테스트 : 시간 경과에 따른 시스템 성능 저하를 방지
		3. 회귀 테스트 (regression test) : 기존 시스템 테스트나 통합 테스트 과정에서 발생했던 과거 버그를 다시 테스트하여 재발되지 않도록 예방

 2. 프로덕션 테스트 :  실제 운영중인 서비스의 테스트
    - 실시간 시스템에 대해 실행되며, **블랙박스 테스트**라고도 부른다.
    - 배포 단계에서 실시간 환경의 변경 사항을 감지하고 사용자에게 영향을 최소화
    - Rollouts Entangle Tests (롤아웃, 테스트의 복잡성)
	    - 프로덕션은 항상 격리된 환경이 아니므로, 롤아웃은 소규모 단계로 진행한다.
	    - 테스트가 성공했더라도 해당 버전이 운영 환경에서 실패할 수 있다.
		    - 테스트와 운영 간 불일치 - 구성 파일이 테스트 환경과 달리 운영 환경에서 호환되지 않았다던가.
		    - 오래된 바이너리가 새 구성 파일에서 정의된 값들로 인해 불안정해 질 수 있음
		    - 테스트가 성공해도 운영 환경에서는 예기치 못한 문제가 발생할 가능성이 있다.

3. 설정 테스트 (Configuration Test)
   - 구글에서는 웹 서비스의 설정 파일을 버전 관리 시스템에 저장하고, 테스트를 통해 운영 환경에서의 구성과 비교한다. 
	   - 설정 파일마다 별도의 설정 테스트가 구현되어있어, 실제 운영 환경에서 동작하는 특정 바이너리가 실제로 어떻게 설정되어 있음을 확인하고, 해당 설정 파일과 비교한다.
	   - 실제 체크인 된 특정 버전의 설정 파일로 배포한 버전으로 테스트하여 실제 운영환경과 비교한다.
	- **단순 테스트**:
	    - 실시간 쿼리로 파일 내용을 가져와 비교
	- **복잡 테스트:**
	    - 바이너리에 내장된 기본값을 사용
	    - bash 셸로 명령줄 플래그를 처리하는 경우
	    - 런타임 스케줄에 따라 동작을 설정해야 하는 경우

4. 스트레스 테스트 (Stress Test)
   - 시스템과 구성 요소의 한계를 이해하기 위해 설계됨
   - 특정 서버가 과부하 상태에서 요청이 실패하는 지점을 찾아내어 성능을 최적화하고 조정한다
    - 데이터베이스가 얼마나 차면 쓰기가 실패하는가?
    - 애플리케이션 서버는 초당 몇 개의 쿼리를 처리할 수 있는가?

5. 카나리 테스트 (Canary Test)
   - 서버의 일부 만을 새로운 버전의 바이너리나 설정 파일로 업그레이드 한 후, 일정 기간 동안 살펴보는 형태
   - 예상치 못한 문제가 없으면 롤아웃을 진행하며, 문제가 발생하면 빠르게 롤백
   - 목적: 사용자 트래픽을 점진적으로 노출하여 안정성을 확인한다.
	   - 카나리 테스트를 통해 사용자 트래픽 문제를 탐지하여 롤아웃을 중단하고 문제를 초기에 해결
  - 버그 유형
	  - **U=1:** 단순한 코드 오류로 요청 실패
	  - **U=2:** 데이터 손상으로 후속 요청에 영향을 미침
	  - **U=3:** 손상된 데이터가 이전 요청에도 영향을 미침
- 버그 처리
	- 비정상 응답을 리턴한 로그들을 **회귀 테스트**를 작성하여  U = 1 유형의 단순 오류를 추적
	- 고차원(U=3) 버그는 릴리즈 기간에 찾아내는 것이 중요하다. 조기에 발견하여 운영 부담을 최소화 해야한다.

### 테스트 및 빌드 환경 구성하기

SRE(Site Reliability Engineer)가 팀에 합류할 시점에는 대부분의 프로젝트가 어느 정도 진행된 상태이며, 초기부터 테스트와 실패 시나리오를 설정하지 않은 경우가 많다. 
이럴 때 어디서부터 테스트를 시작해야 할지 결정하는 것이 중요하다.

- **모든 함수와 클래스를 테스트하는 것은 비효율적이므로, 영향이 큰 영역부터 시작**해야한다.
- **우선순위 설정:** 우선순위를 결정한다. 비스니스 관점에서 중요한 기능이나 클래스에 초점을 맞추고 테스트 한다.
- 타 팀이 사용하는 API 식별 : 다른 팀과 통합해서 사용하는 API가 있는가 
  - API가 잘못 동작하면 잘못된 클라이언트를 작성할 위함이 있다.
- **버그 기록:** 모든 발견된 버그를 테스트 케이스를 문서화 한다
	-> 이 과정을 통해 회귀 테스트(Regression Test) 모음이 형성된다.
- **지속적 통합(CI):** 코드 변경 시마다 자동 테스트를 실행하고 실패 시 즉시 알림하는 빌드 시스템 구축
	- 빌드시스템이 문제가 발생한 코드를 보고하면, 당장 하던 일을 멈추고 이를 해결해야한다.
		  - 추후 결함을 발견한 후에 이를 해결하는 것이 더 어렵다
		  - 결함 발견시 우선적으로 이를 해결해야하므로 팀의 생산성 감소된다.
		  - 릴리즈 주기의 가치를 잃게된다. 

ex) Bazel 빌드 시스템은 코드 의존성을 분석하고 변경된 코드에만 테스트를 실행하여 효율성을 높였다


### 대규모 환경에서의 테스트
SRE는 신뢰성을 보장하기 위해 시스템 관점에서 테스트를 어떻게 바라보는가

- 단위 테스트
	- 소규모 단위 테스트는 소스 파일, 테스트 라이브러리, 런타임 라이브러리, 컴파일러, 로컬 하드웨어와 같은 제한된 의존성을 가진다.
	- 단위테스트에서 충분한 테스트 커버리지를 갖고 있어야 한다. 
- 릴리즈 테스트
	- 릴리즈 테스트는 코드에 많은 객체에 의존성을 갖는 경우가 있기 때문에, 프로덕션 환경의 복제본을 필요로 한다.
	- 모든 패치(patch)에 대해 장애 복구 검사를 수행하면 비효율적이므로 최대한 의존 관계에 있는 부분의 불확실성을 최소화 할 수 있는 최소한만의 테스트를 해야한다. 그 적절한 브랜치(branch)를 선택해 테스트를 해야한다.
#### 대규모 환경을 위한 도구 테스트
SRE 도구는 다음과 같은 작업을 수행한다.
- 데이터베이스 성능 메트릭 조회 및 배포
- 가용성 위험에 대한 계획 수립을 위한 사용량 예측
- 사용자에게 노출되지 않는 서비스 복제본 내 데이터 재구성
- 서버 상의 파일 변경

 주요 특징
- 도구들의 부작용이 테스트를 한 mainstream API에 남는다.
- 기존의 validation 과 release barrier를 통해 사용자 대상의 운영환경과 분리되어있다.

#### 자동화 도구의 테스트
자동화 도구 역시 소프트웨어이기 때문에 훨씬 더 세밀한 테스트가 필요하다.

자동화 도구들은 다음과 같은 작업을 수행
- 데이터베이스 인덱스 선택
- 데이터센터 간 로드 밸런싱
- 릴레이 로그 재배치. 
자동화 도구들은 두 가지 특성을 갖는다.  
- 실제 작업은 견고하고 예측 가능하며 잘 테스트된 API를 기반으로 수행된다.
- **작업의 부작용**: 다른 API 클라이언트에는 보이지 않는 불연속성을 초래할 수 있다.

자동화 도구의 테스트는 다른 서비스 계층에서의 변경 전후로 원하는 동작이 유지되는지 검증할 수 있다. 
예를 들어, 데이터베이스는 전달된 쿼리가 적절한 인덱스룰 사용하지 않더라도 올바른 결과를 리턴하도록 노력한다. 
반면, 캐시된 정보를 제공하는 DNS와 같은 문서화된 API 불변성은 이러한 작업 중에 유지되지 않을 수도 있다. 캐시 상태가 다른 시스템으로 전달되지 않는다면 그렇게 동작하지 못하기 때문에

자동화 도구는 환경 변화에 민감하며, 환경 내에서 스스로 변경될 수도 있다. 
- 컨테이너를 위한 자동화 도구는 컨테이너 자체를 재배치하려고 시도할 수 있다.
- 새로운 알고리즘 릴리즈가 불필요한 메모리 페이지를 너무 빨리 만들어내서, 네트워크 대역폭에 영향을 미칠 수 있다.
- 한 자동화 도구가 다른 도구의 환경을 변경하거나, 두 도구가 서로의 환경을 동시에 변경할 수 있다.

이런 기능들에 대한 테스트 커버리지를 구현해야하며, 
체크포인트에 대한 healthcheck 역시 독립적으로 수행되어야한다.

### 재해 테스트

재해 복구 도구는 오프라인 상태에서도 동작할 수 있도록 세심한 주의를 기울여 만들어진다.
- 서비스를 깨끗하게 정지시킨 상태와 동일한 체크포인트 checkpoint 상태 계산한다.
- 계산된 체크포인트 상태를 기존의 재해 무결성 검사 도구들이 사용할 수 있는 적재 가능한(loadable) 상태로 만든다.
- 클린 스타트(clean start) 절차를 트리거하는 릴리즈 경계 도구(release barrier tools) 지원한다.  
????  
만약 이러한 제약(오프라인, 체크포인트, 로드 가능성 등)이 충족되지 않는다면, 해당 도구가 언제든 완벽하게 동작한다는 것을 자신하기 어렵다.


### 지금 필요한 것은 스피드
- 테스트 결과와 신뢰도
	- 코드 저장소의 각 버전(패치)에 대해 정의된 테스트는 통과(Pass) 또는 실패(Fail)로 나타난다.
	- 동일한 테스트라도 반복 실행 시 결과가 달라질 수 있으며, 여러 번의 실행을 통해 통계적 불확실성을 계산하여 실제 성공 또는 실패 확률을 추정할 수 있다.
	- 하지만, 모든 테스트에 대해 이러한 수학적 계산을 해본다는 것은 비현실적이다.
- 효율적인 테스트 실행
	- 여러 시나리오에 대해 가설을 세우고, 적절한 수의 테스트와 반복 실행을 하여 합당한 추론을 이끌어내야 한다.
 - 엔지니어는 자신의 코드가 테스트 실패를 유발했는지, 또는 다른 코드의 문제 때문인지 알고 싶어한다.
 - 테스트 마감일  
	 - 대부분의 테스트는 단순하며, 독립 실행형 바이너리로 작동하며 몇 초 만에 완료된다. - 즉각적 피드백
	 - 반면, 여러 바이너리 또는 다수의 컨테이너를 사용하는 테스트는 시작 시간이 길며 즉각적인 피드백을 하기 어렵기 때문에 배치 테스트로 분류되기도 한다.
	 - 테스트 결과는 엔지니어가 다른 작업으로 전환하기 전에 제공되어야 효율적이다.

### 프로덕션 환경에 배포하기

- 프로덕션 구성 관리는 일반적으로 소스 제어 저장소에 보관되지만, 개발자 소스 코드와는 분리되어 있는 경우가 많다.
- 테스트 인프라도 프로덕션 환경의 설정값을 사용하지 않으며, 동일한 저장소에 있다 해도 별도의 브랜치나 디렉토리 트리에서 관리되어 테스트에선 무시된다.
- 전통적인 환경에서는 소프트엔지니어가 바이너리를 개발하고 이를 관리자가 이를 배포하는 과정에서 테스트와 프로덕션 구성의 분리가 발생한다. 이는 신뢰성과 민첩성을 저해할 수 있다.
- 통합된 버전 관리 및 테스트의 필요하다.
- 통합된 버전 관리와 테스트 환경에서는 분산 아키텍처 마이그레이션 실패 시 더 많은 테스트가 필요하다.

### 테스트는 얼마든지 실패할 수 있다.

- 과거 릴리즈 : 과거에는 소프트웨어가 1년에 한번 릴리즈, 테스트는 대부분 수작업으로 진행되었다. 
  이는 비효율적이었으나 당시에는 자동화의 필요성이 적었다.

- 현대적 릴리즈: 현재는 API 관리 도구와 대규모 코드를 지원하는 언어를 통해 매 몇 분마다 새 버전을 생성할 수 있다. 중간 단계에서 발견된 문제를 즉시 해결하고, 릴리즈 품질을 높일 수 있다.

-> 사용자의 피드백과 운영 데이터를 활용해 테스트 범위를 확장하고, 이를 통해 신뢰성을 유지하면서 릴리즈 속도를 높여야 한다.

설정 파일 관리
- 구성 파일은 MTTR(평균 복구 시간)을 줄이기 위해 빠르게 변경될 수 있어야 하지만, 테스트 및 모니터링 커버리지가 부족하면 사이트 신뢰성에 부정적 영향을 미칠 수 있다.  
- 자주 변경되는 구성 파일은 사용자 애플리케이션 릴리즈처럼 철저히 관리해야 하며, 그렇지 않으면 사이트 신뢰성 문제의 주요 원인이 될 수 있다.
전략
- 각 설정 파일은 충분한 테스트 커버리지를 확보한다.
- 릴리즈에 앞서 릴리즈 테스트를 수행한 후에 파일의 수정이 이뤄져야한다.
- 긴급한 변경을 위해 유리깨기 "break-glass" 메커니즘(테스트가 완료되기 전에 파일을 밀어 넣는)을 제공할 수 있지만, 이는 신뢰성에 영향을 줄 수 있으므로 신중히 사용한다.


### 통합

통합 테스트의 중요성
- 설정 파일을 인터프리터 언어를 통해 작성하는 것은 잠재적인 실패를 완전하게 처리하기 어렵기에 어려움에 따른다.
- yaml 과 같이 이미 정해진 문법과 파이썬의 safe_load 처럼 확실하게 테스트된 파서를 사용하는 것이 더 효과적이다.
- 프로토콜 버퍼(protocol buffer)를 사용하면 스키마가 미리 정의되고 로드 시 자동으로 체크할 수 있다.

## 프로덕션 환경 조사하기 (Production Probes)

테스트와 모니터링의 역할
- 테스트는 알려진 데이터에 대해 동작을 확인하고, 모니터링은 알 수 없는 사용자 데이터를 기반으로 동작을 확인한다.
### Monitoring probes 

**Monitoring Probes**는 **모니터링을 위한 테스트 도구**로, 실제 운영 중인 프로덕션 환경에서 시스템이 제대로 작동하고 있는지 확인하기 위해 **테스트 요청을 보내는 역할** 
- 프로덕션에서 지속적으로 실행되며, 시스템의 이상 여부를 빠르게 감지
- 릴리즈 테스트와 프로덕션 테스트

세가지 주요 요청 유형
- Known bad requests: 이미 문제가 있는 것으로 판명된 요청으로 에러가 발생해야함
- **프로덕션에서 테스트 가능한 좋은 요청(Known good requests)**: 정상 응답이 반환되어야 함
- **프로덕션에서 테스트 불가능한 좋은 요청**: 문제는 없는 것으로 판명됐지만, 프로덕션에 대해 테스트가 풀가능한 요청

monitoring probes: 사전에 테스트한 적 없는 새로운 조합 점검
- 릴리즈 테스트(배포전 테스트)는 프론트엔드와 가짜 백엔드(fake backend)로 서버에서 수행.
- probes 테스트(프로덕션 테스트?)는 로드 밸런싱 프론트엔드와 별도의 확장 가능한 백엔드에서 수행.
- 프론트엔드와 백엔드는 각각 독립된 릴리즈 주기를 가진다. 이로 인해 프로덕션 환경에서 이전에 테스트한 적 없는 설정을 포함할 수 있다. (릴리즈 테스트와 프로덕션 테스트는 서로 다른 환경에서 실행)

Probes 가 실패한다?
-> 프론트엔드 API 혹은 백엔드 API 가 서로 동일하지 않는다는 것을 의미한다.
(프론트엔드와 백엔드는 각각 독립된 릴리즈 주기를 가져서??)


#### Probes 업데이트와 롤백

점진적 업데이트 (Gradual Updates)
- 새로운 애플리케이션 버전과 이전 버전에 대해 네가지 종류의 Probe가 이뤄진다.
- 네가지 중 하나의 조합에서 문제가 발생하면 업데이트가 멈추고 **마지막으로 정상적으로 작동했던 상태로 롤백**한다.

준비성 확인 (Readiness Check)
- 새 애플리케이션 인스턴스는 **완전히 준비 상태가 될 때까지** 사용자 요청을 받지 않는다.
- Probes를 활용하여 새 애플리케이션이 안전하지 않다고 판단되면, **업데이트를 무기한 연기하고 해결될때까지 트래픽을 전달하지 않는다.**

#### Fake Backend Versions
릴리즈 테스트에서 가짜 백엔드란?**
- 실제 백엔드를 시뮬레이션하는 시스템. 
  예를 들어, 실제 데이터베이스 대신 더 간단한 데이터나 가상 데이터를 반환하는 백엔드
