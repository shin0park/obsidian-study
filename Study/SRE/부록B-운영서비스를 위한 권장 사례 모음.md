
#### 분별 있게 실패하기
- **입력 값 검증 및 유효성 확인**  
    잘못된 설정 입력값이 발생할 경우 이전 상태를 유지하면서 알림 생성해야한다.
    - **부정확한 데이터:** 구문 및 의미론적 검증 수행. 데이터가 비어 있거나 잘려진 경우 경고
    - **지연된 데이터:** 시간 초과로 현재 데이터가 무효화될 수 있음
- **예시**
    - 2005년, Google DNS 시스템이 빈 DNS 파일을 수락하여 6분간 NXDOMAIN 응답을 제공. 이후 새로운 구성 파일에 유효성 검사를 추가하여 문제를 방지
    - 2009년, 잘못된 데이터로 인해 웹 전체를 악성 코드로 잘못 인지. 구성 파일 크기의 급격한 변경 감지 및 유효성 검사를 통해 운영에서 발생하지 않도록 조치

#### 점진적 롤아웃 (Progressive Rollouts)
- **비긴급 변경**은 단계적으로 진행해야 하며, 작은 트래픽이나 용량에 먼저 적용.
- 각 단계는 **지리적 차이를 고려**하여 지역별로 실행해 지역 트래픽 차이를 탐지.
- **예시**  
    롤아웃 중 이상 행동이 감지되면, MTTR을 최소화하기 위해 먼저 롤백 후 진단을 진행하여 복구 시간을 최소화

#### 사용자 중심의 SLO 정의 (Define SLOs Like a User)
- 최종 **사용자 관점**에서 가용성과 성능을 측정하자
- **예시**  
    에러율과 지연응답을 서버가 아닌 Gmail 클라이언트에서 측정하면서 가용성을 위한 자산이 현식적으로 줄어들었고 그 결과 99.0%에서 99.9% 가용성을 확보함

#### 에러 예산 (Error Budgets)
- **서비스 허용 오류 비율**로 예산을 설정 (SLO 기준)
- 예: 가용성 99.99% 서비스는 0.01%의 오류 예산 보유
- 예산을 초과하지 않으면 개발 팀은 얼마든지 새로운 기능 업데이트 배포가은
- 예산 초과 시 변경 사항 동결!
- **효과**
    - SRE와 개발 팀 간 갈등 해소
    - 더 빠른 혁신과 출시를 지원

#### 모니터링
- 모니터링 출력은 세 가지 유형으로 나뉜다.
    - **Pages:** 즉각적인 조치 필요.
    - **Tickets:** 몇 일 내 조치 필요.
    - **Logging:** 분석을 위해 기록만 필요.
- ex
    이메일로 알림 전송은 비효율적이며 결국 무시될 가능성이 크다. -> 마치 /dev/null 에 넣는 것과 같음

#### Postmortem
- 비난하지 않는 것이 중요하다. 
- 당시 최선의 선택을 했다고 가정하자
- 같은 현상이 발생하지 않도록 시스템 디자인을 개선하거나 적절한 정보를 더 쉽게 접할 수 있게 하자
- 운영 상의 의사결정에 대한 검증을 자동화하자

#### 수용량 계획 (Capacity Planning)
- N+2 전략
	-  트래픽이 최고치일때 최대 2개의 인스턴스가 사용 불가능한 상태가 되더라도 N개의 인스턴스가 이를 감당하도록
	- 부하테스트를 통해 리소스당 수용량 비율을 검증하자

#### 과부하와 장애 (Overloads and Failure)
- 과부하 상태에서도 **합리적이고 단순화된 결과 제공**.
- ex
    - Google 검색은 과부하 시 작은 범위의  인덱스를 검색하고즉시검색 같은 기능을 중지하여 과부화 상태에서도 좋은 품질의 결과 제공
    - 재시도 요청으로 오류 증폭 방지를 위해 부하가 총 수용량을 넘어서는 시점부터 재시도를 포함하여 유입되는 트래픽 중 일부는 처리하지 않는다.
    - 에러 확산을 방지하기 위해 재시도 요청 보내기 전에 두배의 시간을 기다리는 기능을 구현해야한다.

#### SRE팀
- **운영 작업 비율**은 50%를 넘지 않도록 유지
- **최적화 방안**
    - 제품 개발자도 온콜 로테이션에 포함 필요
    - SRE와 개발 팀 간 정기 회의로 협력 강화 필요
- ex
    한 온콜 근무당 최대 2개 장애 처리 권장한다. 더 많은 장애처리는 시스템 디자인 또는 모니터링 주기 및 포스트모텀 버그에 대한 대응 중 최소 하나는 문제가 있다는 의미