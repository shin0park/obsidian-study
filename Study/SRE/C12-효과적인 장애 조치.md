### 효과적인 장애 조치

#### 장애조치

- 장애조치를 자주 경험하는 사람은 마치 몸에 배인듯 자연스럽다. 이처럼 [장애조치]는 학습과 가르침이 가능한 부분이다.
- 장애조치는 문제 해결에 대한 지식과 시스템에 대한 이해가 조화를 이루어야 효율적이다. 
- 장애 조치 방법은 *가설 연역 방법 (hypothetico-deductive method)* 을 적용하는 과정이다.
	- 시스템에 대한 관찰을 기반으로 원인 가설을 새우고 이를 테스트하여 원인을 찾아내는 것
	- 관찰된 시스템 상태를 이론과 비교 or 시스템을 적극적으로 고쳐보며 그 반응을 관찰하는 방법 존재.
	- 둘중 어느 방법을 사용하든 결국 근본 원인이 발견될때까지 지속하며, 발견된 경우 재발 방지를 위한 조치와 포스트모템을 작성해야한다.
	- 직접적인 원인은 근본 원인을 발견하거나 문서 작성하기전에 기다릴 필요없이 바로 수정해도 무방하다.
- 통상적으로 피해야하는 문제점:
	- 보통 시스템에 대한 깊은 이해가 부족한 데서 발생하며 아래와 같다.
		- 관련 없는 증상에 집중하거나 시스템 메트릭을 오해하는 경우
		- 안전하게 시스템을 변경하여 테스트하는 방법을 잘 모르는 경우
		- 지나치게 희박한 가설을 세우거나 과거의 한 번 발생한 문제가 다시 발생할 거라고 단정해버리는 경우
		- 단순한 우연의 일치나 동일한 원인에 의해 발생한 현상을 계속 쫒아다니는 경우
	- 이를 피하기 위해서는 -> 문제 해결에 대한 경험을 쌓거나 모든 장애가 똑같은 발생 가능성을 갖지 않는다는 것 그리고 연관 현상들은 원인이 아니라는 등의 논리적 사고가 필요하다.

#### 실전에서의 장애조치

이상과는 거리가 있지만 좀더 수월하게 조치하기 위한 몇 단계들이 있다.

1. 문제 보고: 
   - 첫단계는 보고부터 시작한다.
   - 효과적인 보고는 실제 기대한 동작, 현재는 어떻게 동작하는지, 재현 방법을 포함해야한다.
   - 문제 보고는 일정한 양식으로 구성되어 버그 추적시스템과 같은 검색이 가능한 위치에 저장되어야한다.
   - 구글은 모든 이슈에 대해 버그를 오픈하고 조사 및 조치한 기록을 남긴다. 이는 팀 구성원이 쉽게 공유하고 관리할 수 있다.
2. 문제의 우선순위 판단:
   - 문제 보고 받으면 심각성(영향도)를 판단하고 이에 맞는 대응을 해야한다.
   - 심각한 문제의 경우, 원인 파악보다 시스템 안정화를 우선시 해야한다. 정상 작동하도록 선 조치를 해야한다.
   - Ex) 트래픽을 다른 클러스터로 우회하거나 하위 시스템을 비활성화하는 등.
3. 문제 관찰하기:
   - 문제 발생하면 시스템 각 요소의 상태를 모니터링하여 올바르게 작동하는지 확인해야한다.
   - 시스템의 모든 지표, 시계열 데이터, 로그 등을 통해
   - 로깅: 실시간 문제 해결 및 회고 분석에 유용, 가독성을 위해 선택적 필터링을 하는 것이 좋다. 
   - 현재 시스템 상태를 볼 수 있는 엔드포인트를 마련해 두는 것도 유용하다.
4. 문제 진단:
   문제의 원인 파악하기 위한 몇가지 방식
   - 단순화 하기: 각 단계마다 테스트 데이터를 입력하고 올바른 결과가 출력되는지 확인한다.
   - 범위 좁히기: 시스템을 절반을 나누어 문제가 있는 부분을 찾아간다.
   - 원인파악하기: '무엇', '어디서', '왜' 발생했는지를 파악한다.
   - 마지막 수정부분에 집중(최근 변경사항): 시스템이 잘 작동하다가 최근 변경이 발생한 경우, 그 변경사항을 확인해봐라
   - 서비스에 특화된 진단: 특정 서비스를 분석하는데 도움되는 도구나 시스템 개발하는 것이 좋다.
5. 테스트와 조치
   - 원인 후보를 몇가지 좁혔다면, 이제 어떤 요소가 실제 근본 원인인지 찾기 위해 가설을 하나씩 넣어보거나 배제하며 실험적인 방법을 사용할 수 있다.
   - ex) 애플리케이션 서버와 데이터베이스 서버 간의 네트워크 오류인지, 데이터베이스의 연결 거부가 원인인지 확인할 수 있다. 동일한 자격 증명으로 데이터베이스 연결을 시도하면 후자를 배제할 수 있고, 데이터베이스 서버를 핑(ping)하여 전자의 가능성을 테스트할 수 있다.
   - 테스트 설계시 고려할 점:
     - **상호 배타적 대안**: 이상적인 테스트는 하나의 가설을 검증함으로써 다른 가설을 배제할 수 있도록 설계되어야 한다.
	- **우선순위 적용**: 테스트는 가장 가능성 높은 것부터 시작하며 시스템에 미치는 위험을 고려해야 한다. 
	  예를 들어, 네트워크 연결 문제를 먼저 확인한 후에 설정 변경 여부를 검사하는 것이 좋다.
	- **혼란 요인 제거**: 방화벽 규칙 등 다른 요인으로 인해 테스트 결과가 오해를 불러일으킬 수 있다. 
	  예를 들어 특정 IP만 허용하는 방화벽 규칙으로 인해 핑 테스트가 실패할 수도 있다.
	- **테스트의 부작용**: 테스트가 나중에 실행할 테스트의 결과에 부작용을 초래할 수 있다.
	  예를 들어, 더 방대한 로그를 기록하도록 변경하면 지연응답에 문제가 발생할 수 있고 더 나아가 테스트 결과에 혼선을 줄 수 있다.
	- **결정적이지 않은 테스트**: 교착 상태나 레이스 조건 같은 문제는 재현하기 어려울 수 있어 확실한 증거 대신 암시적 증거에 의존해야 할 때도 있다.
- 마지막으로, 테스트 아이디어와 실행한 테스트, 결과를 명확히 기록하는 것이 중요하다. 
  복잡하고 시간이 오래 걸리는 문제에서는 이러한 기록이 큰 도움이 되며, 체계적으로 문서화된 변경 사항을 통해 시스템을 원래 상태로 돌리기 쉽다.

#### 부정적인 결과의 마법

"부정적인 결과" 예상했던 효과가 나타나지 않는 실험 결과
즉 시스템 도입으로 개선하고자 했으나 의도돼로 되지 않은 경우
- 부정적인 결과는 무시해서도 안되고 평가절하 해서도 안된다.
	- 때로는 가장 어려운 디자인 문제를 해결하기도 한다.
- 부정적인 결과로 끝난 실험 역시 결론이다.
	- 부정적 결과는 프로덕션, 설계 공간, 기존 시스템의 성능한계에 대한 정보를 확실히 제공한다.
	- 한계를 측정
	- 실패로 인한 새로운 선택지나 실수 회피에 도움
	- 문서화된 안티패턴, 포스트모템 들을 제공
- 도구와 방법은 실험의 결과와는 무관하며 향후의 작업에 대한 단서가 된다.
	- 웹 서버 부하 테스트를 위한 Apache Bench는 초기에는 실망스러운 결과였지만, 현재 많은 웹마스터들이 유용하게 사용
- 부정적인 결과를 공표하는 것은 업계의 데이터 주도 성향을 증진시킨다.
	- 부정적 결과를 공개함으로써 측정된 데이터에 근거해 불확실성을 이해하게 하는 좋은 예이다.
	- 높은 품질의 포스트 모템은 안정성에 긍정적인 영향을 가져옴
- 자신의 결과를 공표하자.
	- 부정적 결과도 중요하므로, 다른사람들은 같은 실패를 하지 않도록
	- 데이터를 투명하게 공유하는 문화 독려

#### 문제 해결 요약

1. **근본 원인 입증**
    - 문제 원인을 하나로 좁혔다면, 실제 원인임을 증명하는 것이 필요.
       그러나 실시간 시스템에서 특정 원인을 재현하기는 어려운 경우가 많아, 가능성이 높은 요인을 찾아야 할 때가 많다.
2. **시스템 복잡성**
    - 복잡한 시스템은 여러 요인이 결합되어야 문제가 발생하는 경우가 많다. 
      또한 실제 시스템은 종종 경로 의존적이라 특정 상태에서만 문제가 발생하기도 한다.
3. **운영 중인 프로덕션 시스템에서 문제 재현은 피하자**
	- 시스템 장애가 발생할 상태로 만드는 것이 복잡하며 불필요한 다운타임 발생
    - 비프로덕션 환경은 이러한 문제 해결에 도움을 줄 수 있지만, 시스템 복사본을 추가로 운영해야 하는 부담이 있다.
4. **포스트모템 작성**
    - 문제의 원인, 추적 과정, 해결 방법, 재발 방지 대책을 정리해 포스트모템을 작성한다.

#### App Engine 성능 문제 해결 사례

1. **문제 발생**: 내부 고객이 App Engine을 사용하는 콘텐츠관리시스템 CMS에서 갑작스러운 지연 시간 증가와 CPU 사용량 급증을 보고함.
2. **초기 분석**: 트래픽 급증이나 시스템 변경이 원인이 아니라고 판단, 개발팀이 데이터 저장소 API 호출 문제(merge_join)를 의심했으나 정확한 원인 아님.
3. **추가 조사**: Dapper로 요청을 추적(개별 http요청 처리되는 각 단계 추적)했으나 뚜렷한 원인을 찾지 못해, 임시로 CPU를 강화해 지연 시간을 줄임.
4. **근본 원인**: 보안스캐너가 앱의 취약점 테스트시 부작용으로 인해 수천 개의 불필요한 화이트리스트 객체가 데이터 저장소에 생성됨. 이로 인해 응답 지연 발생.
5. **결과**: 버그를 수정하고 불필요한 객체를 제거하여 성능 정상화.

#### 조금 더  수월하게 장애를 조치하기

1. **observability 초기 구축**: 각 구성 요소에 대해 **화이트박스 메트릭스**와 **구조화된 로그**를 설정하여, 초기 설계 단계에서부터 시스템 관찰을 가능하게 만든다.
2. **명확하고 관찰 가능한 인터페이스 설계**: 시스템 디자인시, 컴포넌트 간 이해가 쉽과 관찰 가능한 인터페이스 마련.
3. **일관된 정보 제공**: **고유 요청 식별자**를 사용하여, upstream, downstream 구성 요소 로그 간의 매칭 시간을 줄이고 진단 및 복구 속도 향상.
4. **코드 및 환경 변경 관리**: 현실 상태를 코드에 정확히 반영하고 이를 간소화 기록함으로써 문제 발생 가능성을 줄이고, 문제 발생 시 해결을 용이하게 한다.