
# Pre-Requisites
## Switching Routing
### Switching
 ![[Pasted image 20240601230113.png|500]]
 **어떻게 A와 B를 연결할까?**
 
스위치: 스위치는 두 시스템을 포함하는 네트워크를 만든다.
인터페이스: 각 컴퓨터를 스위치에 연결하려면, 각 호스트에 인터페이스가 필요하다. 물리적 또는 가상으로
-> `ip link` 명령어를 통해 인터페이스 조회가능하다. eth0 이라는 인터페이스가 조회됨을 볼 수 있다. 
-> 이는 스위치를 연결하는데 사용된다. 

IP주소할당: 주소가 192.168.1.0인 네트워크라고 가정해 보자. 동일한 네트워크에 있는 IP 주소로 시스템을 할당한다. 
-> `ip addr` 커맨드를 사용.  

링크가 작동되고 IP 주소가 할당되면 컴퓨터는 이제 스위치를 통해 서로 통신할 수 있다. 
스위치는 네트워크 내에서만 통신할 수 있다. 
즉, 네트워크의 호스트에서 패킷을 수신하여 *동일한 네트워크 내의* 다른 시스템으로 전달할 수 있는 것이다.
 
### Gateway
![[Pasted image 20240601230130.png|500]]
위 이미지처럼 주소 192.168.2.0에 시스템 C와 D를 포함하는 또 다른 네트워크가 있다고 가정하자. 
#### Routing
**한 네트워크의 시스템이 다른 네트워크의 시스템에 어떻게 도달할 수 있을까?**
-> 라우터
- 라우터는 두 네트워크를 함께 연결하는 데 도움이 되는 지능형 장치이다. 따라서 네트워크 포트가 많은 또 다른 서버로 생각하면된다.
- 두 개의 개별 네트워크에 연결되므로 각 네트워크에 하나씩 두 개의 IP가 할당된다. (192.168. 1. 1, 192.168. 2. 1)

#### Gateway
**시스템 B가 시스템 C로 패킷을 보내려고 할 때 네트워크의 라우터 위치를 어떻게 알 수 있을까?**

라우터는 네트워크의 장치일 뿐이다. 이런 장치는 수 없이 많을 것이다.
이를 위해서는 Gateway or route로 시스템을 구성해야한다.  
네트워크가 방이라면 게이트웨이는 다른 네트워크나 인터넷으로 가는 외부 세계로 통하는 문이다. 
시스템은 문을 통해 어디로 가야 하는지 알아야 한다.  

`route` 커맨드: 시스템의 기존 라우팅 configuration 볼 수 있다. 커널의 라우팅 테이블을 표시. 

route 명령어 입력시, 라우팅 configuration이 없으면, 시스템 B는 시스템 C에 도달할 수 없다. 
192.168. 1. 0 범위 내에서 동일한 네트워크 내의 다른 시스템에만 도달할 수 있다.

네트워크 2.0의 시스템에 도달하도록 시스템 B의 게이트웨이를 구성하려면 
`ip route add` 커맨드를 실행하고, 
192.168.1.1의 문 또는 게이트웨이를 통해 192.168. 2.0에 도달할 수 있도록 지정한다.

![[Pasted image 20240602005724.png|500]]
인터넷에는 다양한 네트워크에 다양한 사이트가 있는데, 동일한 라우터 IP 주소를 라우팅 테이블에 추가하는 대신,
라우트를 모르는 네트워크에 대해 이 라우터를 default 게이트웨이로 사용한다고 간단히 말할 수 있습니다. 
-> 기존 네트워크 외의 외부의 네트워크에 대한 모든 요청이 이 특정 라우터로 이동합니다.  

![[Pasted image 20240602010139.png|500]]
- default 대신 0.0.0.0이라고 표현해도 된다. - 이는 모든 IP 대상을 의미 
- 0.0.0.0 게이트웨이 필드 항목은 게이트웨이가 필요하지 않음을 나타낸다. 
  예를 들어, 시스템 C는 192. 168. 2. 0 네트워크에서는 자체 네트워크에 있기 때문에 게이트웨이가 필요하지 않다.  
  
![[Pasted image 20240602010355.png|500]]
- 하나는 인터넷용이고 다른 하나는 내부 개인 네트워크용으로 구성한다면, 각 네트워크에 대해 두 개의 별도 항목이 있어야 한다.
- 내부 개인 네트워크에 대한 항목 하나와, 공용 네트워크를 포함한 다른 모든 네트워크에 대한 default 게이트웨이가 있는 다른 항목
- 시스템에서 인터넷에 연결하는 데 문제가 있는 경우 이 라우팅 테이블과 default 게이트웨이 configuration을 시작으로 살펴보는 것이 좋다.

#### Linux 호스트를 라우터로 설정하는 방법
![[Pasted image 20240602011536.png|500]]
**A가 C와 대화하게 하려면 어떻게 해야 할까?** 
`ping` - 호스트 A는 192,168.2. 네트워크에 도달하는 방법을 모른다 

따라서,
 A에게 192.168.1.6 게이트웨이를 통해 네트워크 192.168.2 에 액세스하기 위한 라우트를 추가해야한다.
반대로 C에서 A로 돌아갈때도 마찬가지로 route를 추가해줘야한다.

그리고 ping을 시도하면 더 이상 네트워크에 연결할 수 없다는 오류 메시지가 표시되지 않는다. 
이는 라우팅 항목이 옳다는 것을 의미한다.

그러나 여전히 어떤 응답도 받지 못하는데, 
*default로 Linux에서는 패킷이 한 인터페이스에서 다음 인터페이스로 전달되지 않는다.*
호스트 B의 eth0에서 수신된 패킷은 eth1을 통해 다른 곳으로 전달되지 않는다. - 보안상의 이유 때문 
예를들어, eth0이 개인 네트워크에 연결되어 있고 eth1이 공용 네트워크에 연결되어 있는 경우, 명시적으로 허용하지 않는 한 공용 네트워크의 어느 누구도 개인 네트워크로 메시지를 쉽게 보낼 수 없어야 되기 때문이다.

지금 예제의 경우 둘 다 사설 네트워크이고 둘 사이의 통신을 가능하게 하는 것이 안전하다는 것을 알고 있으므로, 허용하고자 한다면,
`proc/sys/net/ipv4/ip_forward`
: 이 시스템의 설정에 따라 결정
default : 0
단, 이 값을 설정하는 것만으로는 재부팅 후에도 변경 사항이 지속되지 않는다는 점 기억.
변경사항이 재부팅 후에도 지속되기 위해서는 `etc/sys/control.conf` 파일 에서 동일한 값을 수정해야 한다.

![[Pasted image 20240602012300.png|500]]
`ip link`: 호스트의 인터페이스 나열
`ip addr`: 인터페이스에 할당된 IP 주소를 확인
`ip addr add`: 인터페이스에 IP 주소를 설정
`ip route` `route`: 라우팅 테이블 조회
`ip route add`: 라우팅 테이블에 route 추가 
`cat /proc/sys/net/ipv4/ip_forward`: 라우터로 구성된 호스트로 작업하는 경우 호스트에서 IP 전달이 활성화되어 있는지 확인

## DNS
![[Pasted image 20240602013353.png|500]]
복잡한 IP 주소 대신 특정 Name으로 서버에 ping을 날릴 수 있는데,
시스템 A의 `etc/hosts` 파일에 항목을 추가하여 이를 수행할 수 있다. 

그리고 `etc/hosts` 파일에 넣은 것이 진실인지 아닌지는 상관 없이 호스트 A는 이를 당연하게 여긴다. 
즉, 호스트 A는 시스템 B의 실제 이름이 db인지 확인하지 않는다. 
예를 들어, 시스템 B에서 hostname 커맨드를 실행하면 이름이 host-2라는 것을 알 수 있으며, 호스트 A는 신경 쓰지 않고, 호스트 파일에 있는 내용으로 이동한다.

시스템 B가 Google이라고 믿도록 시스템 A를 속일 수도 있다. www.google.com에 대한 IP 매핑을 사용하여 호스트 파일에 항목을 추가하기만 하면 된다. 
하나는 db이고 다른 하나는 Google로 동일한 시스템을 가리키는 두 개의 이름이 생기게 되며,  두 이름 중 하나를 사용하여 시스템 B를 읽을 수 있게된다.
-> *`etc/hosts` 파일에서 원하는 만큼의 서버에 대해 원하는 만큼의 이름을 가질 수 있다.*

호스트 A에서 이름으로 다른 호스트를 참조할 때마다 ping 커맨드나 SSH 커맨드를 통해 또는 이 시스템 내의 애플리케이션이나 tool을 통해 호스트는 해당 호스트의 IP 주소를 찾기 위해 etc/hosts 파일을 찾는다.

-> 이러한 방식으로 호스트 이름을 IP 주소로 변환하는 것을 *name resolution*이라고 한다.

![[Pasted image 20240602014151.png|500]]
환경이 커질 수록 앞서 설명한 항목들을 관리하는 것은 너무 어려워진다. 따라서 중앙에서 단일 서버를 두어 이를 관리하게 되는데,
이를 *DNS 서버*라고 한다.
IP 주소를 확인해야하는 경우에 모든 호스트가 해당 DNS 서버를 조회하도록 지정해서 사용할 수 있다.
-> `etc/resolv.conf` - DNS resolution configuration file

![[Pasted image 20240602013531.png|500]]
DNS 서버를 설정해도, etc/hosts 파일에 따로 정의해서 사용할 수도 있긴 하다. 
-> 호스트는 먼저 로컬 etc/hosts 파일에서 그런 다음 이름 서버를 확인한다. 
![[Pasted image 20240602014545.png|300]]
하지만 찾는 순서는 `etc/nsswitch.conf` 파일의 항목으로 정의해서 변경할 수 있다.
파일은 etc/hosts 파일을 의미하고 DNS는 DNS 서버를 의미

**목록에 없는 서버에 ping을 시도하면 어떻게 될까?** 
예를 들어 www.facebook.com에 ping을 시도
etc/hosts 파일에 facebook.com이 없고 DNS 서버에도 없다. 따라서 그 경우에는 실패한다.  

#### 공용 DNS 서버
8.8.8.8은 Google에서 호스팅하는 인터넷에서 사용할 수 있는 널리 알려진 공용 DNS 서버로 인터넷의 모든 웹사이트에 대해 알고 있다. 
알 수 없는 호스트 이름을 인터넷의 공용 이름 서버로 전달하도록 DNS 서버 자체를 구성할 수 있다. 
-> Forward All to 8.8.8.8

![[Pasted image 20240602013550.png|500]]
점으로 구분된 이 형식을 사용하는 이유는 유사한 항목을 함께 그룹화하기 위함이다.
도메인 이름의 마지막 부분인 .coms, .nets, .edu, .org 등은 웹사이트의 의도를 나타내는 최상위 도메인이다. 
상업용 또는 일반용 .com, 네트워크용 .net, 교육 기관용 .edu, 비영리 기관용 .org. 

- drive.google.com
- apps.google.com
- mail.google.com
각각을 많은 하위 도메인으로 추가로 나눌 수 있으며, 트리구조로 형성된다.

![[Pasted image 20240602023617.png|500]]
- 조직 내에서 이러한 도메인 이름(예: apps.google.com)에 도달하려고 하면, 
- 요청이 먼저 조직의 내부 DNS 서버에 도달하며, 누구인지 모르기 때문에 요청을 인터넷으로 전달한다. 
- 인터넷에서 apps.google.com을 제공하는 서버의 IP 주소는 여러 DNS 서버의 도움을 받아 확인할 수 있다. 
- root DNS 서버는 요청을 보고 .coms를 제공하는 DNS 서버를 가리키고 com DNS 서버는 우리의 요청을 보고 Google DNS 서버에 전달하게 된다. 그리고 Google의 DNS 서버는 IP를 제공한다.
향후의 모든 확인 속도를 높이기 위해 DNS 서버는 일정 시간 동안 이 IP를 캐싱하도록 설정할 수 있다. 

![[Pasted image 20240602024432.png|500]]
만약, web이라고만 쳐도 web.mycompany.com을 나타내고 싶으면 어떻게 할까?
-> *Search Domain*
etc/resolv.conf 파일에 search 항목을 만들고 추가할 도메인 이름을 지정하면, 
web에 ping을 하면, 실제로 web.mycompany.com을 시도하는 것을 볼 수 있다. 

![[Pasted image 20240602023647.png|500]]
A 레코드: IP
CNAME: 다른 이름에 매핑

![[Pasted image 20240602023708.png|300]]
nslookup: DNS 서버에서 호스트 이름을 쿼리 가능. 
그러나 nslookup은 로컬 `etc/hosts` 파일의 항목을 고려하지 않는다.

![[Pasted image 20240602023721.png|500]]
dig도 마찬가지
서버에 저장된 것과 유사한 형식으로 자세한 내용을 반환

## Network Namespace


컨테이너는 네임스페이스를 사용하여 호스트와 컨테이너 공간이 분리되며, 호스트는 컨테이너 내부에서 실행되는 프로세스를 포함하여 모든 프로세스를 볼 수 있지만, 컨테이너의 네임스페이스에서는 그 컨테이너 내부에서 실행되는 프로세스만 볼 수 있다.
![[Pasted image 20240603010246.png|500]]
컨테이너가 생성되면 네트워크 네임스페이스를 생성하므로 호스트의 네트워크 관련 정보를 볼 수 없다.
네임스페이스 내에서 컨테이너는 자체 가상 인터페이스, 라우팅 및 ARP 테이블을 가질 수 있다.


#### Create Network Namespace
![[Pasted image 20240603010739.png|300]]
`ip netns add` : Linux 호스트에서 새 네트워크 네임스페이스 생성. 
`ip netns`: 네트워크 네임스페이스를 조회


#### Exec in Network Namespace
![[Pasted image 20240603010821.png|500]]
`ip link`: 호스트의 인터페이스를 조회. 

red 또는 blue 네임스페이스 내에서 동일한 커맨드를 어떻게 실행하는가? 
커맨드 앞에 `ip netns exec` 커맨드를 붙인 다음 네임스페이스 이름(red)을 붙인다.
-> red 네임스페이스 내에서 ip link 커맨드가 실행된다.
== ip link 커맨드에 -n 옵션을 추가
-> 더 간단하지만 네임스페이스 내에서 ip 커맨드를 실행하려는 경우에만 작동한다.  

![[Pasted image 20240603011126.png|400]]
ARP ,route 테이블도 마찬가지


#### Namespace 간의 통신 
가상 인터페이스 또는 가상 케이블을 사용하여 두 개의 네임스페이스를 함께 연결할 수 있다. - pipe

![[Pasted image 20240603011922.png|500]]
- 케이블을 생성하려면 유형을 veth로 설정하고 ip link add 커맨드를 실행하고 두 끝 veth red 및 veth blue를 지정
- 각 인터페이스를 적절한 네임스페이스에 연결 
- 각 네임스페이스에 IP 주소를 할당 
- 각 네임스페이스 내의 각 장치에 대해 ip link set up 커맨드 통해 링크가 작동하고 이제 네임스페이스가 서로 연결할 수 있게 된다.

![[Pasted image 20240603011932.png|500]]
ARP 테이블을 보면 MAC 주소가 있는 192.168.15.2에서 blue 이웃을 식별하는 것을 볼 수 있다. 서로를 식별하고 있다. 
호스트 ARP 테이블은 우리가 생성한 이러한 새 네임스페이스에 대해 전혀 모르고 그 안에 생성한 인터페이스에 대해 전혀 모른다는 것을 알 수 있다.

#### Linux Bridge
![[Pasted image 20240603011947.png|500]]
네임스페이스가 더 많으면? 서로 의사 소통을 할 수 있게 하려면 어떻게 해야 할까?
호스트 내부에 가상 네트워크를 만든다.
네트워크를 생성하려면 스위치가 필요하므로 가상 네트워크를 생성하려면 가상 스위치가 필요하다. 
-> 호스트 내에 가상 스위치를 생성하고 여기에 네임스페이스를 연결란다. 
-> *Linux Bridge*

내부 브리지 네트워크를 생성하기 위해 유형이 bridge로 설정된 `ip link add` 커맨드를 사용하여 호스트에 새 인터페이스를 추가한다. 
ip link로 인터페이스 조회시, 현재 꺼져 있으므로 `ip link set up` 커맨드를 사용하여 킨다.

![[Pasted image 20240603013022.png|300]]
`ip link delete` : 이전에 위에서 만들었던 인터페이스를 삭제
한쪽 끝 링크를 삭제하면 다른쪽도 자동 삭제됨.

네임스페이스를 브리지에 연결하는 새 케이블 생성.

![[Pasted image 20240603012710.png|500]]
케이블이 준비되었으므로 네임스페이스에 연결할 차례이다.
모두 연결하고 link set up 으로 켰으면,
네 개의 네임스페이스가 모두 내부 브리지 네트워크에 연결되어 있으며 모두 서로 통신할 수 있게 된다.

#### 외부와의 통신

외부 세계로 통하는 유일한 문은 호스트의 이더넷 포트이다.
그렇다면 이더넷 포트를 통해 회선 네트워크에 도달하도록 이 브리지를 구성하려면 어떻게 해야 할까?

![[Pasted image 20240603014048.png|500]]
외부 LAN 네트워크에도 연결되는 시스템 -> 모든 네임스페이스가 있는 로컬 호스트 -> 로컬 호스트에는 개인 네트워크를 연결하는 인터페이스가 있으므로 네임스페이스를 ping할 수 있다. -> 로컬 호스트는 두 네트워크를 함께 연결하는 게이트웨이

blue 네임스페이스에  route 추가하여 192.168.15.5의 게이트웨이를 통해 모든 트래픽을 192.168.1 네트워크로 라우팅할 수 있게 한다. 

![[Pasted image 20240603014113.png|500]]
홈 네트워크에는 내부 사설 IP 주소가 있으므로, 자체 주소로 LAN에 메시지를 보낼 수 있도록 여기에서 게이트웨이 역할을 하는 호스트에서 NAT 활성화가 필요하다.

![[Pasted image 20240603014226.png|500]]
우리는 라우팅 테이블을 보고 네트워크 192.168.1에 대한 route가 있지만 다른 route는 없음을 확인 할 수 있다. 
-> 호스트를 지정하는 default 게이트웨이를 추가해야 가능하다.

### Docker Networking

Docker의 기본 네트워킹 옵션
Docker가 설치된 서버인 단일 Docker 호스트라고 가정.
- None: `docker run --network none nginx`
  도커 컨테이너는 네트워크에 연결되지 않는다.- 컨테이너는 외부 세계에 도달할 수 없고, 서로서로 연결 할 수도 없다.
- Host: `docker run --network host nginx`
  컨테이너가 호스트 네트워크에 연결, 호스트와 컨테이너 간에는 네트워크 분리가 없다.
- Bridege: `docker run nginx`
  Docker 호스트 및 컨테이너가 연결되는 내부 전용 네트워크가 생성된다. 
  네트워크에는 기본적으로 주소 172.17.0.0 이 있으며, 
  이 네트워크에 연결된 각 장치는 이 네트워크에서 자체 내부 전용 네트워크 주소를 얻는다.
![[Pasted image 20240603020425.png|200]]

![[Pasted image 20240603020528.png|500]]
호스트에 Docker를 설치하면 기본적으로 Bridge라는 내부 전용 네트워크가 생성된다. 
도커는 브리지로 설정된 유형으로 IP link add 명령을 실행하여 네임스페이스에서 강의에서 본 것과 유사한 기술을 내부적으로 사용한다.

![[Pasted image 20240603020824.png|500]]
컨테이너가 생성될 때마다 Docker는 컨테이너에 대한 네트워크 네임스페이스를 생성한다. 
 Docker inspect 명령 출력에서 각 컨테이너와 연결된 네임스페이스를 확인할 수 있다.

![[Pasted image 20240603021114.png|500]]
그렇다면 Docker는 컨테이너 또는 네트워크 네임스페이스를 브리지 네트워크에 어떻게 연결할까?
*컨테이너와 네트워크 네임스페이스는 동일한 것을 의미한다.*  
그렇다면 도커는 어떻게 컨테이너를 브릿지에 부착할까?  
이전과 동일하게, 양쪽 끝에 두 개의 인터페이스가 있는 가상 케이블을 만든다. 
Docker 호스트에서 IP link 명령을 실행하면 로컬 브리지인 Docker0에 연결된 인터페이스의 한쪽 끝이 표시된다. 
네임스페이스가 있는 -n 옵션을 사용하여 동일한 명령을 다시 실행하면 컨테이너 네임스페이스 내 인터페이스의 다른 쪽 끝이 나열되고, 인터페이스는 네트워크 내에서 IP를 할당받음을 볼 수 있다.

![[Pasted image 20240603021329.png|500]]
새 컨테이너가 생성될 때마다 동일한 절차가 수행되며,
도커는 네임스페이스를 만들고, 인터페이스 쌍을 만들고, 한쪽 끝을 컨테이너에 연결하고, 다른 쪽 끝을 브리지 네트워크에 연결한다. 
인터페이스 쌍은 번호를 사용하여 식별할 수 있는데, 홀수와 짝수가 짝을 이룬다.

#### port
![[Pasted image 20240603022729.png|500]]
![[Pasted image 20240603022748.png|500]]
*외부 사용자가 컨테이너에 호스팅된 응용프로그램에 액세스할 수 있도록 도커는 포트 매핑 옵션을 제공한다.*
컨테이너를 실행할 때 Docker에게 Docker 호스트의 포트 8080을 컨테이너의 포트 80에 매핑하도록 지시한다. 
이렇게 하면 도커 호스트의 IP와 포트 8080을 사용하여 웹 애플리케이션에 액세스할 수 있다. 

어떻게 한 포트에서 다른 포트로 트래픽을 전달할까? 
NAT은 이를 위한 NAT 규칙을 만듭니다. 
IP 테이블을 사용하여 NAT 테이블에 항목을 생성하여 대상 포트를 8080에서 80으로 변경하는 규칙을 사전 라우팅 체인에 추가한다. 


### CNI
모든 사용자가 단일 표준 세트를 준수하고 실행 시간에 걸쳐 작동하는 솔루션을 개발할 수 있을텐데,
여기서 컨테이너 네트워크 인터페이스가 등장하게 된다.

CNI는 컨테이너 런타임 환경에서 네트워킹 문제를 해결하기 위해 프로그램을 개발하는 방법을 정의하는 표준의 집합이다.
프로그램을 플러그인이라고 하는데, 이 경우, 이전에 언급한 Bridge 프로그램은 CNI를 위한 플러그인이다. 
CNI는 플러그인이 어떻게 개발되어야 하는지, 컨테이너 런타임이 어떻게 그것들을 호출해야 하는지를 정의한다고 보면 된다.
![[Pasted image 20240603021934.png|600]]
CNI는 컨테이너 실행 시간 및 플러그인에 대한 일련의 책임을 정의한다.
- 컨테이너 런타임의 경우, CNI는 각 컨테이너에 대한 네트워크 namespace을 생성하도록 지정. 
- 그런 다음 컨테이너가 연결되어야 하는 네트워크를 식별해야 하며, 
- 컨테이너 런타임은 add 커맨드를 사용하여 컨테이너를 생성할 때 플러그인을 호출해야 하며, 
- del 커맨드를 사용하여 컨테이너를 삭제할 때 플러그인을 호출해야 한다. 
- JSON 파일을 사용하여 컨테이너 런타임 환경에서 네트워크 플러그인을 구성
- 플러그인 측에서는 플러그인이 추가, del 및 check 커맨드라인 arguments를 지원해야 하며 컨테이너 및 네트워크 네임스페이스와 같은 매개 변수를 허용해야 한다고 정의한다. 
- 플러그인은 컨테이너가 네트워크의 다른 컨테이너에 도달하는 데 필요한 파드 및 관련 경로에 IP 주소를 할당해야 한다. 
- 결과를 특정 형식으로 지정해야 한다. 

![[Pasted image 20240603022448.png|500]]
모든 컨테이너 런타임은 CNI 표준을 구현하므로 이러한 플러그인 중 하나라도 작동할 수 있다.

*하지만 도커는 CNI를 구현하지 않는다.* 
도커는 CNM이라는 자체 표준을 가지고 있는데, CNI와 유사하지만 약간의 차이가 있는 컨테이너 네트워킹 문제를 해결하는 것을 목표로 하는 또 다른 표준인 컨테이너 네트워크 모델을 의미한다.

## Networking Cluster Node

![[Pasted image 20240603085935.png|300]]
- 각 노드에는 네트워크에 연결된 인터페이스가 하나 이상 있어야 한다. 
- 각 인터페이스에는 주소가 있어야 한다.
- 호스트에는 고유한 호스트 이름 집합과 고유한 MAC 주소가 있어야 한다. 
#### port
![[Pasted image 20240603090039.png|500]]
워커 노드, Kube controller manager, 등의 리소스들은 6443 포트를 통해 Kube API 서버에 액세스한다.
kubelet은 10250
...
워커 노드는 포트 30000-32767에서 외부 액세스를 위한 서비스를 Export하므로 이 또한 열려 있어야 한다.

![[Pasted image 20240603090107.png|500]]

