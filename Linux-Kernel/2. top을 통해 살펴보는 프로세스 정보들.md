### 1. 시스템 상태 살피기 

`top` 명령어를 통해 시스템의 전반적인 상태를 빠르게 파악할 수 있다.

1. **구동 시간:** 서버의 현재 시간과 부팅 후 경과 시간(Up time)을 나타낸다.
2. **Load Average:** 현재 시스템이 얼마나 많은 일을 하고 있는지를 나타내는 지표
3. **Tasks:** 현재 구동 중인 프로세스의 개수
4. **CPU/Mem/Swap:** 각 리소스의 사용량을 나타내며, 특히 Swap 사용 여부는 시스템 상태 파악에 중요
5. **프로세스 상세 정보:**
    - **PR/NI:** 프로세스의 실행 우선순위를 결정
    - **VIRT, RES, SHR:** 프로세스가 사용하는 메모리 양을 나타내며, 메모리 누수 확인의 핵심 지표
    - **S (Status):** 프로세스의 상태(CPU 사용 중, I/O 대기, 유휴 상태 등)를 나타냄

### 2. VIRT, RES, SHR의 개념

- **VIRT (Virtual Memory):** 프로세스에 할당된 가상 메모리 전체 크기. 
	- 코드, 데이터, 공유 라이브러리 및 Swap된 페이지를 모두 포함한다. 
	- 실제 할당되지 않은 가상의 공간이므로 이 값이 크다고 해서 반드시 문제가 되지는 않는다.
    
- **RES (Resident Size):** 프로세스가 현재 사용 중인 실제 물리 메모리(RAM) 양. 
	- 메모리 점유율이 높은 프로세스를 찾을 때 가장 중요하게 봐야 할 수치이다.
    
- **SHR (Shared Memory):** 다른 프로세스와 공유하고 있는 메모리 양. 
	- 대표적으로 `glibc`와 같은 라이브러리를 공유하여 메모리 낭비를 방지함
    
### 3. Memory Commit의 이해

- 프로세스가 메모리를 요청했을 때 커널이 즉시 물리 메모리를 할당하지 않고, 가상의 주소만 전달하는 것을 **Memory Commit**이라고 한다.
    
- **동작 과정:** `malloc()` 요청 시 가상 메모리(VIRT)만 증가하며, 실제 쓰기 작업 시 `Page fault` 발생 후 물리 메모리(RES)에 바인딩됨.
    
- **Copy-On-Write (COW):** 
	- `fork()` 시 자식 프로세스는 부모의 메모리 영역을 그대로 복사한 것처럼 보이지만, 실제 쓰기 작업이 발생하기 전까지는 메모리 할당을 지연시켜 효율성을 높인다.
	  
- **Overcommit:** 커널은 가용 메모리보다 더 많은 메모리를 프로세스에게 약속할 수 있다. 
	- 이는 효율적이지만 시스템 응답 불가(Hang)를 초래할 수 있다.
    
- **vm.overcommit_memory 파라미터 제어:**

    - **0 (기본값):** 커널이 판단하여 가용 공간보다 작을 때만 커밋 허용.
    - **1:** 요청된 모든 메모리에 대해 무조건 커밋 진행. 메모리 누수 시 위험할 수 있음
    - **2:** swap 영역과 `vm.overcommit_ratio` 설정 비율에 따라 제한적으로 커밋함.
---
`+`
- **OOM Killer (Out Of Memory Killer)**
	- Memory Commit과 Overcommit이 허용된 상태에서 물리 메모리가 한계에 도달하면, 커널은 시스템 보호를 위해 특정 프로세스를 강제로 종료시킨다. 
	- 어떤 프로세스가 먼저 죽을지는 `oom_score`에 의해 결정된다.
- **sar를 통한 추적**
	- `sar -r` 명령어를 활용하면 실시간이 아닌 **과거의 메모리 커밋 기록**을 볼 수 있다. 
	- 장애가 발생했던 시점의 `%commit` 수치를 확인하여 메모리 부족 여부를 사후 분석할 때 매우 유용하다
- **Page Cache와의 관계**
	- `top`에서 보이는 가용 메모리가 적어 보여도, 많은 부분이 `cached` 영역으로 잡혀있다면 실제로는 여유가 있는 것이다. 
	- 커널은 I/O 성능 향상을 위해 남는 메모리를 페이지 캐시로 활용하며, 프로세스가 메모리를 필요로 하면 즉시 이를 비우고 할당해 준다

### 4. 프로세스의 상태 보기

`top` 출력 항목 중 `S` 열은 프로세스의 현재 상태를 나타내며, `man` 페이지에서는 다섯 가지로 정의한다.

- **D (Uninterruptible sleep):** 
	- 디스크나 네트워크 I/O를 대기하며 대기 큐(Wait Queue)에 머무는 상태. 
	- 프로세스가 응답을 받을 때까지 아무것도 할 수 없으므로 CPU 사용권을 다른 프로세스에 넘김
	- 즉 interrupt 불가하며 부하 계산(Load Average)에 포함됨
    
- **R (Running):** 실제로 CPU 자원을 소모하며 실행 중인 프로세스
    
- **S (Sleeping):** 요청한 리소스를 즉시 사용할 수 있는 interrupt 가능한 대기 상태. 
	- 특정 시그널을 받으면 즉시 처리할 수 있는 상태로 마킹되어 대기함
    
- **T (Traced or Stopped):** `strace` 등으로 시스템 콜을 추적 중이거나 일시 정지된 상태
    
- **Z (Zombie):** 실행이 완료되었으나 부모 프로세스가 종료 상태를 확인하지 않아 프로세스 테이블에 남아 있는 상태.
	- 즉, PID만 점유한 상태

> **핵심 포인트:** 시스템 부하 계산 시 **D 상태** 프로세스가 많으면 특정 요청이 끝나기를 기다리는 프로세스가 많다는 뜻이므로 부하 수치에 포함된다.
        
### 5. 좀비 프로세스와 PID 고갈

프로세스는 `fork()`로 생성되어 부모-자식 관계를 맺으며, 자식이 종료되면 부모에게 이를 알려 정보를 정리해야 한다.

- **좀비 프로세스의 발생:** 부모 프로세스가 먼저 종료되거나 자식의 종료 신호를 제대로 처리하지 못할 때 발생
    
- **문제점:** 좀비 프로세스는 CPU나 메모리 리소스를 차지하지는 않지만, **PID(Process ID)**를 점유한다.
    
- **PID 고갈:** 리눅스 커널 파라미터 `kernel.pid_max`에 정의된 최대값(예: 65536)까지 좀비 프로세스가 쌓이면 새로운 프로세스에 할당할 PID가 부족해져 더 이상 프로세스를 생성할 수 없게 된다.

### 6. 프로세스의 우선순위: PR과 NI

커널 스케줄러는 **Run Queue**에 연결된 프로세스 중 우선순위가 가장 높은 것을 꺼내 CPU에 할당(Dispatch)한다.

- **PR (Priority):** 커널이 인식하는 실제 우선순위 값.
    
- **NI (Nice value):** 우선순위를 조절할 때 사용하는 값(-20 ~ 19). 낮을수록 우선순위가 높음.
    
- **상관관계:** 기본 PR(20)에 NI 값을 더해 최종 PR이 결정됨
    
- **스케줄링 특징:** 
	- CPU 코어 수보다 실행 중인 프로세스 수가 적으면 `nice` 설정 효과가 미비하지만, 코어 수보다 많은 프로세스가 경쟁할 때 비로소 우선순위 설정의 효과가 확실하게 나타남
    
- **RT (RealTime):** 특정 시간 안에 반드시 종료되어야 하는 중요 프로세스(커널 데몬 등)에 적용되며, 일반 사용자 프로세스보다 항상 먼저 실행된다.

###  요약

- **top 활용:** 시스템 전체 리소스(CPU, Mem, Swap)와 개별 프로세스의 점유 상태를 한눈에 확인할 수 있다.
- **메모리 지표:** **VIRT**는 가상 메모리 전체, **RES**는 실제 물리 메모리 사용량, **SHR**은 공유 메모리 양을 의미한다.
- **Memory Commit:** 프로세스가 메모리를 요청할 때 커널이 즉시 물리 메모리를 주지 않고 실제 사용할 때 할당하는 방식
- **커널 파라미터:** `vm.overcommit_memory`를 통해 커널의 메모리 커밋 동작 방식(무조건 허용, 제한적 허용 등)을 제어할 수 있다.